/*
Data Streaming - OpenAPI

The Data Streaming API allows you to manage your existing data streamings and templates. Data Streaming allows you to feed your stream processing, SIEM, and big data platforms with the event logs from your applications on Azion in real time. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package data_streaming

import (
	"encoding/json"
	"fmt"
)

// DataStreamingResponseWithResultsResultsInner struct for DataStreamingResponseWithResultsResultsInner
type DataStreamingResponseWithResultsResultsInner struct {
	DataStreamingResponseGetResultTypeCustom *DataStreamingResponseGetResultTypeCustom
	DataStreamingResponseGetResultTypeDatadogDTS *DataStreamingResponseGetResultTypeDatadogDTS
	DataStreamingResponseGetResultTypeKafka *DataStreamingResponseGetResultTypeKafka
	DataStreamingResponseGetResultTypeStandard *DataStreamingResponseGetResultTypeStandard
}

// Unmarshal JSON data into any of the pointers in the struct
func (dst *DataStreamingResponseWithResultsResultsInner) UnmarshalJSON(data []byte) error {
	var err error
	// try to unmarshal JSON data into DataStreamingResponseGetResultTypeCustom
	err = json.Unmarshal(data, &dst.DataStreamingResponseGetResultTypeCustom);
	if err == nil {
		jsonDataStreamingResponseGetResultTypeCustom, _ := json.Marshal(dst.DataStreamingResponseGetResultTypeCustom)
		if string(jsonDataStreamingResponseGetResultTypeCustom) == "{}" { // empty struct
			dst.DataStreamingResponseGetResultTypeCustom = nil
		} else {
			return nil // data stored in dst.DataStreamingResponseGetResultTypeCustom, return on the first match
		}
	} else {
		dst.DataStreamingResponseGetResultTypeCustom = nil
	}

	// try to unmarshal JSON data into DataStreamingResponseGetResultTypeDatadogDTS
	err = json.Unmarshal(data, &dst.DataStreamingResponseGetResultTypeDatadogDTS);
	if err == nil {
		jsonDataStreamingResponseGetResultTypeDatadogDTS, _ := json.Marshal(dst.DataStreamingResponseGetResultTypeDatadogDTS)
		if string(jsonDataStreamingResponseGetResultTypeDatadogDTS) == "{}" { // empty struct
			dst.DataStreamingResponseGetResultTypeDatadogDTS = nil
		} else {
			return nil // data stored in dst.DataStreamingResponseGetResultTypeDatadogDTS, return on the first match
		}
	} else {
		dst.DataStreamingResponseGetResultTypeDatadogDTS = nil
	}

	// try to unmarshal JSON data into DataStreamingResponseGetResultTypeKafka
	err = json.Unmarshal(data, &dst.DataStreamingResponseGetResultTypeKafka);
	if err == nil {
		jsonDataStreamingResponseGetResultTypeKafka, _ := json.Marshal(dst.DataStreamingResponseGetResultTypeKafka)
		if string(jsonDataStreamingResponseGetResultTypeKafka) == "{}" { // empty struct
			dst.DataStreamingResponseGetResultTypeKafka = nil
		} else {
			return nil // data stored in dst.DataStreamingResponseGetResultTypeKafka, return on the first match
		}
	} else {
		dst.DataStreamingResponseGetResultTypeKafka = nil
	}

	// try to unmarshal JSON data into DataStreamingResponseGetResultTypeStandard
	err = json.Unmarshal(data, &dst.DataStreamingResponseGetResultTypeStandard);
	if err == nil {
		jsonDataStreamingResponseGetResultTypeStandard, _ := json.Marshal(dst.DataStreamingResponseGetResultTypeStandard)
		if string(jsonDataStreamingResponseGetResultTypeStandard) == "{}" { // empty struct
			dst.DataStreamingResponseGetResultTypeStandard = nil
		} else {
			return nil // data stored in dst.DataStreamingResponseGetResultTypeStandard, return on the first match
		}
	} else {
		dst.DataStreamingResponseGetResultTypeStandard = nil
	}

	return fmt.Errorf("data failed to match schemas in anyOf(DataStreamingResponseWithResultsResultsInner)")
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src *DataStreamingResponseWithResultsResultsInner) MarshalJSON() ([]byte, error) {
	if src.DataStreamingResponseGetResultTypeCustom != nil {
		return json.Marshal(&src.DataStreamingResponseGetResultTypeCustom)
	}

	if src.DataStreamingResponseGetResultTypeDatadogDTS != nil {
		return json.Marshal(&src.DataStreamingResponseGetResultTypeDatadogDTS)
	}

	if src.DataStreamingResponseGetResultTypeKafka != nil {
		return json.Marshal(&src.DataStreamingResponseGetResultTypeKafka)
	}

	if src.DataStreamingResponseGetResultTypeStandard != nil {
		return json.Marshal(&src.DataStreamingResponseGetResultTypeStandard)
	}

	return nil, nil // no data in anyOf schemas
}

type NullableDataStreamingResponseWithResultsResultsInner struct {
	value *DataStreamingResponseWithResultsResultsInner
	isSet bool
}

func (v NullableDataStreamingResponseWithResultsResultsInner) Get() *DataStreamingResponseWithResultsResultsInner {
	return v.value
}

func (v *NullableDataStreamingResponseWithResultsResultsInner) Set(val *DataStreamingResponseWithResultsResultsInner) {
	v.value = val
	v.isSet = true
}

func (v NullableDataStreamingResponseWithResultsResultsInner) IsSet() bool {
	return v.isSet
}

func (v *NullableDataStreamingResponseWithResultsResultsInner) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableDataStreamingResponseWithResultsResultsInner(val *DataStreamingResponseWithResultsResultsInner) *NullableDataStreamingResponseWithResultsResultsInner {
	return &NullableDataStreamingResponseWithResultsResultsInner{value: val, isSet: true}
}

func (v NullableDataStreamingResponseWithResultsResultsInner) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableDataStreamingResponseWithResultsResultsInner) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


